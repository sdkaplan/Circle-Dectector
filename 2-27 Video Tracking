"""
Tracking Swarm Robots
Created on Fri Mar  8 12:42:57 2019
@author: M.R.Bonthron
Illinois Institute of Technology
"""
#%% Import the tools needed for the rest of the program
import cv2 as cv
import numpy as np
import time
import math
#import matplotlib as mathplotlib

start_time = time.time()                # Times how long the program runs for 
numFrameToSave = 10                     # Number of frames to skip [frames]
camerafps = 30                          # Frames per second the camera shoots at [frames / second]
interval = numFrameToSave / camerafps   # How many seconds apart are each of the inspected frames [seconds]
conversion = 1080 / 1080                  # PIXELS / UNITS    eg [pixels /  cm]
units = 'pixels'
number_of_objects = 1

#%% Sets up the Color Detection and data storage
# define the list of boundaries for color detection
# ([Blue,Green,Red],[Blue,Green,Red])
boundaries =[
([104 , 175 , 195] , [164 , 235 , 255]),
]
#Names of the Colors
colors = ['Object 1','Object 2','Object 3','Object 4','Object 5','Object 6','Object 7','Object 8','Object 9','Object 10','Object 11','Object 12',]

#Sets up empty list to store center values 
centerPoints = [[] for i in range(number_of_objects)]         


#%% Acesses the webcam
#Imports the Video as a webcam
vidcap = cv.VideoCapture(0)
cv.namedWindow("Web Cam")
    
for i in range(1,number_of_objects):
    cv.namedWindow("Filter %s" % i)

#%% Inserts the counters                          
indexcounter = 0                                    #Index counter is so we can access the previous location to calculate the speed
framenumber = 0

#%% Accesses the webcam 
if vidcap.isOpened(): # try to get the first frame
    rval, image = vidcap.read()
else:
    rval = False
#%% While it is able to access the webcam successfully
while rval:
    cv.imshow("Web Cam", image)
    rval, image = vidcap.read()
    
    if (framenumber % numFrameToSave == 0):
        circleNum = 0
        print('\nFrameNumber:',framenumber)
        print('-------------------------')
        
# Loop over the boundaries: Looking for each color in boundaries 
        for (lower, upper) in boundaries:
            lower = np.array(lower, dtype="uint8")
            upper = np.array(upper, dtype="uint8")
            
# find the colors within the specified boundaries and apply the mask
            mask = cv.inRange(image, lower, upper)              
            output = cv.bitwise_and(image, image, mask=mask)
               
            cv.imwrite('temp.png',output)
            filename = "temp.png" 
            
# Shows the what the filter has applied to determine Hough 
            if circleNum == 0:
                cv.imshow("Filter 1",output)
            elif circleNum == 1:
                cv.imshow("Filter 2", output)
            
#%% Finds the centroid of the pixels of a certain color
            src = cv.imread(filename, cv.IMREAD_COLOR)  # Reads the file name and stores it as src in Color
            gray = cv.cvtColor(src, cv.COLOR_BGR2GRAY)  # Converts the src to a gray scale picture for the threshold change to calculate the centroid
            
            ret,thresh = cv.threshold(gray ,127 ,255, 0) #Applied the threshold to set pixels either as white or as black
            
            M = cv.moments(thresh)  #Determines the centroid of only the white images pixels
            
# If a cenroid is found
            if M["m00"] != 0.0 :
                xcenter = int(M["m10"] / M["m00"])
                ycenter = int(M["m01"] / M["m00"])
# If no centroid is found, but there is information from previous data
            elif len(centerPoints[circleNum]) >= 1:
                previousLocation = (centerPoints[circleNum])[indexcounter - 1]
                xcenter = previousLocation[0]
                ycenter = previousLocation[1]
# If no centroid is found and there is no information from previous data
            else:
                xcenter = 0
                ycenter = 0

#%% Storing the center data        
            center = [xcenter,ycenter]                         
            centerPoints[circleNum].append(center)

# Calculates the speed of the object over the last time interval if there has been more than 1 data point collected
            if len(centerPoints[circleNum]) >= 1:
                previousLocation = (centerPoints[circleNum])[indexcounter - 1]
                xprevious = previousLocation[0]
                yprevious = previousLocation[1]
                distance = math.sqrt((xcenter - xprevious)**2 + (ycenter - yprevious)**2)      # Distance the circle traveled in [cm]
                speed = distance / interval
                    
                
#%% Prints the information in the console to see
            print(colors[circleNum],'\t', )
            print('%.2f, %.2f %s' % (xcenter,ycenter,units))
            print('Previous %.2f %.2f %s' % (xprevious,yprevious,units))
            print('Distance %.2f %s' % (distance,units))
            print('Speed: %.2f %s / second' % (speed,units))
            
        
            circleNum = circleNum + 1               # Circle number loops over the boundaries to change what number circle is being identified
        indexcounter = indexcounter + 1          # Should be outside of the for loop in boundaries changes what number picture we are looking at count / numberofframestoskip
#%% Determines how many frames the camera has captured so far     
    framenumber = framenumber +1
#%% How to exit the code    
    key = cv.waitKey(20)
    if key == 27: # exit on ESC
        break
#%% End of code release the camera     
vidcap.release()
cv.destroyAllWindows()
